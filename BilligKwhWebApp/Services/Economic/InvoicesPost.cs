// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using BilligKwhWebApp.Services.Invoicing.Economic;
//
//    var invoicesPost = InvoicesPost.FromJson(jsonString);

namespace BilligKwhWebApp.Services.Economic.InvoicesPost
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    /// <summary>
    /// A schema for creating a draft invoice.
    /// </summary>
    public partial class InvoicePost
    {
        /// <summary>
        /// The ISO 4217 3-letter currency code of the invoice.
        /// </summary>
        [JsonProperty("currency")]
        public string Currency { get; set; }

        /// <summary>
        /// The customer being invoiced.
        /// </summary>
        [JsonProperty("customer")]
        public Customer Customer { get; set; }

        /// <summary>
        /// Invoice issue date. Format according to ISO-8601 (YYYY-MM-DD).
        /// </summary>
        [JsonProperty("date")]
        public string Date { get; set; }

        /// <summary>
        /// The actual place of delivery for the goods on the invoice. This is usually the same place
        /// as the one referenced in the deliveryLocation property, but may be edited as required.
        /// </summary>
        [JsonProperty("delivery", NullValueHandling = NullValueHandling.Ignore)]
        public Delivery Delivery { get; set; }

        /// <summary>
        /// A reference to the place of delivery for the goods on the invoice
        /// </summary>
        [JsonProperty("deliveryLocation", NullValueHandling = NullValueHandling.Ignore)]
        public DeliveryLocation DeliveryLocation { get; set; }

        /// <summary>
        /// The date the invoice is due for payment. Only used if the terms of payment is of type
        /// 'duedate', in which case it is mandatory. Format according to ISO-8601 (YYYY-MM-DD).
        /// </summary>
        [JsonProperty("dueDate", NullValueHandling = NullValueHandling.Ignore)]
        public string DueDate { get; set; }

        /// <summary>
        /// The desired exchange rate between the invoice currency and the base currency of the
        /// agreement. The exchange rate expresses how much it will cost in base currency to buy 100
        /// units of the invoice currency. If no exchange rate is supplied, the system will get the
        /// current daily rate, unless the invoice currency is the same as the base currency, in
        /// which case it will be set to 100.
        /// </summary>
        [JsonProperty("exchangeRate", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MinMaxValueCheckConverter))]
        public double? ExchangeRate { get; set; }

        /// <summary>
        /// The total invoice amount in the invoice currency after all taxes and discounts have been
        /// applied. For a credit note this amount will be negative.
        /// </summary>
        [JsonProperty("grossAmount", NullValueHandling = NullValueHandling.Ignore)]
        public double? GrossAmount { get; set; }

        /// <summary>
        /// The total invoice amount in the base currency of the agreement after all taxes and
        /// discounts have been applied. For a credit note this amount will be negative.
        /// </summary>
        [JsonProperty("grossAmountInBaseCurrency", NullValueHandling = NullValueHandling.Ignore)]
        public double? GrossAmountInBaseCurrency { get; set; }

        /// <summary>
        /// The layout used by the invoice.
        /// </summary>
        [JsonProperty("layout")]
        public Layout Layout { get; set; }

        /// <summary>
        /// An array containing the specific invoice lines.
        /// </summary>
        [JsonProperty("lines", NullValueHandling = NullValueHandling.Ignore)]
        public InvoiceLine[] Lines { get; set; }

        /// <summary>
        /// The difference between the cost price of the items on the invoice and the sales net
        /// invoice amount in base currency. For a credit note this amount will be negative.
        /// </summary>
        [JsonProperty("marginInBaseCurrency", NullValueHandling = NullValueHandling.Ignore)]
        public double? MarginInBaseCurrency { get; set; }

        /// <summary>
        /// The margin expressed as a percentage. If the net invoice amount is less than the cost
        /// price this number will be negative.
        /// </summary>
        [JsonProperty("marginPercentage", NullValueHandling = NullValueHandling.Ignore)]
        public double? MarginPercentage { get; set; }

        /// <summary>
        /// The total invoice amount in the invoice currency before all taxes and discounts have been
        /// applied. For a credit note this amount will be negative.
        /// </summary>
        [JsonProperty("netAmount", NullValueHandling = NullValueHandling.Ignore)]
        public double? NetAmount { get; set; }

        /// <summary>
        /// Notes on the invoice.
        /// </summary>
        [JsonProperty("notes", NullValueHandling = NullValueHandling.Ignore)]
        public Notes Notes { get; set; }

        /// <summary>
        /// The terms of payment for the invoice.
        /// </summary>
        [JsonProperty("paymentTerms")]
        public PaymentTerms PaymentTerms { get; set; }

        /// <summary>
        /// References a pdf representation of this invoice.
        /// </summary>
        [JsonProperty("pdf", NullValueHandling = NullValueHandling.Ignore)]
        public Pdf Pdf { get; set; }

        /// <summary>
        /// The project the invoice is connected to.
        /// </summary>
        [JsonProperty("project", NullValueHandling = NullValueHandling.Ignore)]
        public Project Project { get; set; }

        /// <summary>
        /// The actual recipient of the invoice. This may be the same info found on the customer (and
        /// will probably be so in most cases) but it may also be a different recipient. For
        /// instance, the customer placing the order may be ACME Headquarters, but the recipient of
        /// the invoice may be ACME IT.
        /// </summary>
        [JsonProperty("recipient")]
        public Recipient Recipient { get; set; }

        /// <summary>
        /// Customer and company references related to this invoice.
        /// </summary>
        [JsonProperty("references", NullValueHandling = NullValueHandling.Ignore)]
        public References References { get; set; }

        /// <summary>
        /// The total rounding error, if any, on the invoice in base currency.
        /// </summary>
        [JsonProperty("roundingAmount", NullValueHandling = NullValueHandling.Ignore)]
        public double? RoundingAmount { get; set; }

        /// <summary>
        /// The total amount of VAT on the invoice in the invoice currency. This will have the same
        /// sign as net amount
        /// </summary>
        [JsonProperty("vatAmount", NullValueHandling = NullValueHandling.Ignore)]
        public double? VatAmount { get; set; }
    }

    /// <summary>
    /// The customer being invoiced.
    /// </summary>
    public partial class Customer
    {
        /// <summary>
        /// The customer id number. The customer id number can be either positive or negative, but it
        /// can't be zero.
        /// </summary>
        [JsonProperty("customerNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? CustomerNumber { get; set; }

        /// <summary>
        /// A unique reference to the customer resource.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// The actual place of delivery for the goods on the invoice. This is usually the same place
    /// as the one referenced in the deliveryLocation property, but may be edited as required.
    /// </summary>
    public partial class Delivery
    {
        /// <summary>
        /// Street address where the goods must be delivered to the customer.
        /// </summary>
        [JsonProperty("address", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(PurpleMinMaxLengthCheckConverter))]
        public string Address { get; set; }

        /// <summary>
        /// The city of the place of delivery
        /// </summary>
        [JsonProperty("city", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public string City { get; set; }

        /// <summary>
        /// The country of the place of delivery
        /// </summary>
        [JsonProperty("country", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public string Country { get; set; }

        /// <summary>
        /// The date of delivery.
        /// </summary>
        [JsonProperty("deliveryDate", NullValueHandling = NullValueHandling.Ignore)]
        public string DeliveryDate { get; set; }

        /// <summary>
        /// Details about the terms of delivery.
        /// </summary>
        [JsonProperty("deliveryTerms", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(TentacledMinMaxLengthCheckConverter))]
        public string DeliveryTerms { get; set; }

        /// <summary>
        /// The zip code of the place of delivery.
        /// </summary>
        [JsonProperty("zip", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(StickyMinMaxLengthCheckConverter))]
        public string Zip { get; set; }
    }

    /// <summary>
    /// A reference to the place of delivery for the goods on the invoice
    /// </summary>
    public partial class DeliveryLocation
    {
        /// <summary>
        /// A unique identifier for the delivery location.
        /// </summary>
        [JsonProperty("deliveryLocationNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? DeliveryLocationNumber { get; set; }

        /// <summary>
        /// A unique reference to the delivery location resource.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// The layout used by the invoice.
    /// </summary>
    public partial class Layout
    {
        /// <summary>
        /// A unique identifier of the layout.
        /// </summary>
        [JsonProperty("layoutNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? LayoutNumber { get; set; }

        /// <summary>
        /// A unique reference to the layout resource.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// An array of the invoice lines that make up the invoice.
    /// </summary>
    public partial class InvoiceLine
    {
        /// <summary>
        /// The accrual for the invoice.
        /// </summary>
        [JsonProperty("accrual", NullValueHandling = NullValueHandling.Ignore)]
        public Accrual Accrual { get; set; }

        /// <summary>
        /// A departmental distribution defines which departments this entry is distributed between.
        /// This requires the departments module to be enabled.
        /// </summary>
        [JsonProperty("departmentalDistribution", NullValueHandling = NullValueHandling.Ignore)]
        public DepartmentalDistribution DepartmentalDistribution { get; set; }

        /// <summary>
        /// A description of the product or service sold. Please note, that when setting existing
        /// products, description field is required. While setting non-existing product, description
        /// field can remain empty.
        /// </summary>
        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(IndigoMinMaxLengthCheckConverter))]
        public string Description { get; set; }

        /// <summary>
        /// A line discount expressed as a percentage.
        /// </summary>
        [JsonProperty("discountPercentage", NullValueHandling = NullValueHandling.Ignore)]
        public double? DiscountPercentage { get; set; }

        /// <summary>
        /// The line number is a unique number within the invoice.
        /// </summary>
        [JsonProperty("lineNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? LineNumber { get; set; }

        /// <summary>
        /// The difference between the net price and the cost price on the invoice line in base
        /// currency.
        /// </summary>
        [JsonProperty("marginInBaseCurrency", NullValueHandling = NullValueHandling.Ignore)]
        public double? MarginInBaseCurrency { get; set; }

        /// <summary>
        /// The margin on the invoice line expressed as a percentage.
        /// </summary>
        [JsonProperty("marginPercentage", NullValueHandling = NullValueHandling.Ignore)]
        public double? MarginPercentage { get; set; }

        /// <summary>
        /// The product or service offered on the invoice line.
        /// </summary>
        [JsonProperty("product", NullValueHandling = NullValueHandling.Ignore)]
        public Product Product { get; set; }

        /// <summary>
        /// The number of units of goods on the invoice line.
        /// </summary>
        [JsonProperty("quantity", NullValueHandling = NullValueHandling.Ignore)]
        public double? Quantity { get; set; }

        /// <summary>
        /// A sort key used to sort the lines in ascending order within the invoice.
        /// </summary>
        [JsonProperty("sortKey", NullValueHandling = NullValueHandling.Ignore)]
        public long? SortKey { get; set; }

        /// <summary>
        /// The unit of measure applied to the invoice line.
        /// </summary>
        [JsonProperty("unit", NullValueHandling = NullValueHandling.Ignore)]
        public Unit Unit { get; set; }

        /// <summary>
        /// The cost price of 1 unit of the goods or services in the invoice currency.
        /// </summary>
        [JsonProperty("unitCostPrice", NullValueHandling = NullValueHandling.Ignore)]
        public double? UnitCostPrice { get; set; }

        /// <summary>
        /// The price of 1 unit of the goods or services on the invoice line in the invoice currency.
        /// </summary>
        [JsonProperty("unitNetPrice", NullValueHandling = NullValueHandling.Ignore)]
        public double? UnitNetPrice { get; set; }
    }

    /// <summary>
    /// The accrual for the invoice.
    /// </summary>
    public partial class Accrual
    {
        /// <summary>
        /// The end date for the accrual. Format: YYYY-MM-DD.
        /// </summary>
        [JsonProperty("endDate", NullValueHandling = NullValueHandling.Ignore)]
        public string EndDate { get; set; }

        /// <summary>
        /// The start date for the accrual. Must be within an existing accounting year. Format:
        /// YYYY-MM-DD.
        /// </summary>
        [JsonProperty("startDate", NullValueHandling = NullValueHandling.Ignore)]
        public string StartDate { get; set; }
    }

    /// <summary>
    /// A departmental distribution defines which departments this entry is distributed between.
    /// This requires the departments module to be enabled.
    /// </summary>
    public partial class DepartmentalDistribution
    {
        /// <summary>
        /// A unique identifier of the departmental distribution.
        /// </summary>
        [JsonProperty("departmentalDistributionNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? DepartmentalDistributionNumber { get; set; }

        /// <summary>
        /// Type of the distribution
        /// </summary>
        [JsonProperty("distributionType", NullValueHandling = NullValueHandling.Ignore)]
        public string DistributionType { get; set; }

        /// <summary>
        /// A unique reference to the departmental distribution resource.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// The product or service offered on the invoice line.
    /// </summary>
    public partial class Product
    {
        /// <summary>
        /// The unique product number. This can be a stock keeping unit identifier (SKU).
        /// </summary>
        [JsonProperty("productNumber", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(IndecentMinMaxLengthCheckConverter))]
        public string ProductNumber { get; set; }

        /// <summary>
        /// A unique reference to the product resource.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// The unit of measure applied to the invoice line.
    /// </summary>
    public partial class Unit
    {
        /// <summary>
        /// A unique reference to the unit resource.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }

        /// <summary>
        /// The unique identifier of the unit.
        /// </summary>
        [JsonProperty("unitNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? UnitNumber { get; set; }
    }

    /// <summary>
    /// Notes on the invoice.
    /// </summary>
    public partial class Notes
    {
        /// <summary>
        /// The invoice heading. Usually displayed at the top of the invoice.
        /// </summary>
        [JsonProperty("heading", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(HilariousMinMaxLengthCheckConverter))]
        public string Heading { get; set; }

        /// <summary>
        /// The first line of supplementary text on the invoice. This is usually displayed right
        /// under the heading in a smaller font.
        /// </summary>
        [JsonProperty("textLine1", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(AmbitiousMinMaxLengthCheckConverter))]
        public string TextLine1 { get; set; }

        /// <summary>
        /// The second line of supplementary text in the notes on the invoice. This is usually
        /// displayed as a footer on the invoice.
        /// </summary>
        [JsonProperty("textLine2", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(AmbitiousMinMaxLengthCheckConverter))]
        public string TextLine2 { get; set; }
    }

    /// <summary>
    /// The terms of payment for the invoice.
    /// </summary>
    public partial class PaymentTerms
    {
        /// <summary>
        /// The number of days of credit on the invoice. This field is only valid if terms of payment
        /// is not of type 'duedate
        /// </summary>
        [JsonProperty("daysOfCredit", NullValueHandling = NullValueHandling.Ignore)]
        public long? DaysOfCredit { get; set; }

        /// <summary>
        /// A unique identifier of the payment term.
        /// </summary>
        [JsonProperty("paymentTermsNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? PaymentTermsNumber { get; set; }

        /// <summary>
        /// The type the payment term.
        /// </summary>
        [JsonProperty("paymentTermsType", NullValueHandling = NullValueHandling.Ignore)]
        public PaymentTermsType? PaymentTermsType { get; set; }

        /// <summary>
        /// A unique reference to the payment term resource.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// References a pdf representation of this invoice.
    /// </summary>
    public partial class Pdf
    {
        /// <summary>
        /// The unique reference of the pdf representation for this draft invoice.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// The project the invoice is connected to.
    /// </summary>
    public partial class Project
    {
        /// <summary>
        /// A unique identifier of the project.
        /// </summary>
        [JsonProperty("projectNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? ProjectNumber { get; set; }

        /// <summary>
        /// A unique reference to the project resource.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// The actual recipient of the invoice. This may be the same info found on the customer (and
    /// will probably be so in most cases) but it may also be a different recipient. For
    /// instance, the customer placing the order may be ACME Headquarters, but the recipient of
    /// the invoice may be ACME IT.
    /// </summary>
    public partial class Recipient
    {
        /// <summary>
        /// The street address of the actual recipient.
        /// </summary>
        [JsonProperty("address", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(HilariousMinMaxLengthCheckConverter))]
        public string Address { get; set; }

        /// <summary>
        /// The person to whom this invoice is addressed.
        /// </summary>
        [JsonProperty("attention", NullValueHandling = NullValueHandling.Ignore)]
        public Attention Attention { get; set; }

        /// <summary>
        /// The city of the actual recipient.
        /// </summary>
        [JsonProperty("city", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(HilariousMinMaxLengthCheckConverter))]
        public string City { get; set; }

        /// <summary>
        /// The country of the actual recipient.
        /// </summary>
        [JsonProperty("country", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public string Country { get; set; }

        /// <summary>
        /// The 'European Article Number' of the actual recipient.
        /// </summary>
        [JsonProperty("ean", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(CunningMinMaxLengthCheckConverter))]
        public string Ean { get; set; }

        /// <summary>
        /// The phone number the invoice was sent to (if applicable).
        /// </summary>
        [JsonProperty("mobilePhone", NullValueHandling = NullValueHandling.Ignore)]
        public string MobilePhone { get; set; }

        /// <summary>
        /// The name of the actual recipient.
        /// </summary>
        [JsonProperty("name")]
        [JsonConverter(typeof(HilariousMinMaxLengthCheckConverter))]
        public string Name { get; set; }

        /// <summary>
        /// Chosen NemHandel type used for e-invoicing.
        /// </summary>
        [JsonProperty("nemHandelType")]
        public NemHandelType? NemHandelType { get; set; }

        /// <summary>
        /// The public entry number of the actual recipient.
        /// </summary>
        [JsonProperty("publicEntryNumber", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(MagentaMinMaxLengthCheckConverter))]
        public string PublicEntryNumber { get; set; }

        /// <summary>
        /// Recipient vat zone.
        /// </summary>
        [JsonProperty("vatZone")]
        public VatZone VatZone { get; set; }

        /// <summary>
        /// The zip code of the actual recipient.
        /// </summary>
        [JsonProperty("zip", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(FluffyMinMaxLengthCheckConverter))]
        public string Zip { get; set; }
    }

    /// <summary>
    /// The person to whom this invoice is addressed.
    /// </summary>
    public partial class Attention
    {
        /// <summary>
        /// Unique identifier of the customer employee.
        /// </summary>
        [JsonProperty("customerContactNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? CustomerContactNumber { get; set; }

        /// <summary>
        /// A unique reference to the customer employee.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// Recipient vat zone.
    /// </summary>
    public partial class VatZone
    {
        /// <summary>
        /// A unique reference to the vat zone.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }

        /// <summary>
        /// Unique identifier of the vat zone.
        /// </summary>
        [JsonProperty("vatZoneNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? VatZoneNumber { get; set; }
    }

    /// <summary>
    /// Customer and company references related to this invoice.
    /// </summary>
    public partial class References
    {
        /// <summary>
        /// The customer contact is a reference to the employee at the customer to contact regarding
        /// the invoice.
        /// </summary>
        [JsonProperty("customerContact", NullValueHandling = NullValueHandling.Ignore)]
        public CustomerContact CustomerContact { get; set; }

        /// <summary>
        /// A text field that can be used to save any custom reference on the invoice.
        /// </summary>
        [JsonProperty("other", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(HilariousMinMaxLengthCheckConverter))]
        public string Other { get; set; }

        /// <summary>
        /// The primary sales person is a reference to the employee who sold the goods on the invoice.
        /// </summary>
        [JsonProperty("salesPerson", NullValueHandling = NullValueHandling.Ignore)]
        public SalesPerson SalesPerson { get; set; }

        /// <summary>
        /// A reference to any second employee involved in the sale.
        /// </summary>
        [JsonProperty("vendorReference", NullValueHandling = NullValueHandling.Ignore)]
        public VendorReference VendorReference { get; set; }
    }

    /// <summary>
    /// The customer contact is a reference to the employee at the customer to contact regarding
    /// the invoice.
    /// </summary>
    public partial class CustomerContact
    {
        /// <summary>
        /// Unique identifier of the customer contact.
        /// </summary>
        [JsonProperty("customerContactNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? CustomerContactNumber { get; set; }

        /// <summary>
        /// A unique reference to the customer contact resource.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// The primary sales person is a reference to the employee who sold the goods on the invoice.
    /// </summary>
    public partial class SalesPerson
    {
        /// <summary>
        /// Unique identifier of the employee.
        /// </summary>
        [JsonProperty("employeeNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? EmployeeNumber { get; set; }

        /// <summary>
        /// A unique reference to the employee resource.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// A reference to any second employee involved in the sale.
    /// </summary>
    public partial class VendorReference
    {
        /// <summary>
        /// Unique identifier of the employee.
        /// </summary>
        [JsonProperty("employeeNumber", NullValueHandling = NullValueHandling.Ignore)]
        public long? EmployeeNumber { get; set; }

        /// <summary>
        /// A unique reference to the employee resource.
        /// </summary>
        [JsonProperty("self", NullValueHandling = NullValueHandling.Ignore)]
        public Uri Self { get; set; }
    }

    /// <summary>
    /// The type the payment term.
    /// </summary>
    public enum PaymentTermsType { AvtaleGiro, Creditcard, DueDate, Factoring, InvoiceMonth, InvoiceWeekStartingMonday, InvoiceWeekStartingSunday, Net, PaidInCash, Prepaid };

    public enum NemHandelType { CorporateIdentificationNumber, Ean, PNumber };

    public partial class InvoicesPost
    {
        public static InvoicesPost FromJson(string json) => JsonConvert.DeserializeObject<InvoicesPost>(json, Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this InvoicesPost self) => JsonConvert.SerializeObject(self, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                PaymentTermsTypeConverter.Singleton,
                NemHandelTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PurpleMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 255)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 255)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly PurpleMinMaxLengthCheckConverter Singleton = new PurpleMinMaxLengthCheckConverter();
    }

    internal class FluffyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 50)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 50)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly FluffyMinMaxLengthCheckConverter Singleton = new FluffyMinMaxLengthCheckConverter();
    }

    internal class TentacledMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 100)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 100)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly TentacledMinMaxLengthCheckConverter Singleton = new TentacledMinMaxLengthCheckConverter();
    }

    internal class StickyMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 30)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 30)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly StickyMinMaxLengthCheckConverter Singleton = new StickyMinMaxLengthCheckConverter();
    }

    internal class MinMaxValueCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(double) || t == typeof(double?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<double>(reader);
            if (value <= 999999999999)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type double");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (double)untypedValue;
            if (value <= 999999999999)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type double");
        }

        public static readonly MinMaxValueCheckConverter Singleton = new MinMaxValueCheckConverter();
    }

    internal class IndigoMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 2500)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 2500)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly IndigoMinMaxLengthCheckConverter Singleton = new IndigoMinMaxLengthCheckConverter();
    }

    internal class IndecentMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 25)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 25)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly IndecentMinMaxLengthCheckConverter Singleton = new IndecentMinMaxLengthCheckConverter();
    }

    internal class HilariousMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 250)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 250)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly HilariousMinMaxLengthCheckConverter Singleton = new HilariousMinMaxLengthCheckConverter();
    }

    internal class AmbitiousMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 1000)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 1000)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly AmbitiousMinMaxLengthCheckConverter Singleton = new AmbitiousMinMaxLengthCheckConverter();
    }

    internal class PaymentTermsTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PaymentTermsType) || t == typeof(PaymentTermsType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "avtaleGiro":
                    return PaymentTermsType.AvtaleGiro;
                case "creditcard":
                    return PaymentTermsType.Creditcard;
                case "dueDate":
                    return PaymentTermsType.DueDate;
                case "factoring":
                    return PaymentTermsType.Factoring;
                case "invoiceMonth":
                    return PaymentTermsType.InvoiceMonth;
                case "invoiceWeekStartingMonday":
                    return PaymentTermsType.InvoiceWeekStartingMonday;
                case "invoiceWeekStartingSunday":
                    return PaymentTermsType.InvoiceWeekStartingSunday;
                case "net":
                    return PaymentTermsType.Net;
                case "paidInCash":
                    return PaymentTermsType.PaidInCash;
                case "prepaid":
                    return PaymentTermsType.Prepaid;
            }
            throw new Exception("Cannot unmarshal type PaymentTermsType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PaymentTermsType)untypedValue;
            switch (value)
            {
                case PaymentTermsType.AvtaleGiro:
                    serializer.Serialize(writer, "avtaleGiro");
                    return;
                case PaymentTermsType.Creditcard:
                    serializer.Serialize(writer, "creditcard");
                    return;
                case PaymentTermsType.DueDate:
                    serializer.Serialize(writer, "dueDate");
                    return;
                case PaymentTermsType.Factoring:
                    serializer.Serialize(writer, "factoring");
                    return;
                case PaymentTermsType.InvoiceMonth:
                    serializer.Serialize(writer, "invoiceMonth");
                    return;
                case PaymentTermsType.InvoiceWeekStartingMonday:
                    serializer.Serialize(writer, "invoiceWeekStartingMonday");
                    return;
                case PaymentTermsType.InvoiceWeekStartingSunday:
                    serializer.Serialize(writer, "invoiceWeekStartingSunday");
                    return;
                case PaymentTermsType.Net:
                    serializer.Serialize(writer, "net");
                    return;
                case PaymentTermsType.PaidInCash:
                    serializer.Serialize(writer, "paidInCash");
                    return;
                case PaymentTermsType.Prepaid:
                    serializer.Serialize(writer, "prepaid");
                    return;
            }
            throw new Exception("Cannot marshal type PaymentTermsType");
        }

        public static readonly PaymentTermsTypeConverter Singleton = new PaymentTermsTypeConverter();
    }

    internal class CunningMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 13)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 13)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly CunningMinMaxLengthCheckConverter Singleton = new CunningMinMaxLengthCheckConverter();
    }

    internal class NemHandelTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NemHandelType) || t == typeof(NemHandelType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "corporateIdentificationNumber":
                    return NemHandelType.CorporateIdentificationNumber;
                case "ean":
                    return NemHandelType.Ean;
                case "pNumber":
                    return NemHandelType.PNumber;
            }
            throw new Exception("Cannot unmarshal type NemHandelType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (NemHandelType)untypedValue;
            switch (value)
            {
                case NemHandelType.CorporateIdentificationNumber:
                    serializer.Serialize(writer, "corporateIdentificationNumber");
                    return;
                case NemHandelType.Ean:
                    serializer.Serialize(writer, "ean");
                    return;
                case NemHandelType.PNumber:
                    serializer.Serialize(writer, "pNumber");
                    return;
            }
            throw new Exception("Cannot marshal type NemHandelType");
        }

        public static readonly NemHandelTypeConverter Singleton = new NemHandelTypeConverter();
    }

    internal class MagentaMinMaxLengthCheckConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length <= 40)
            {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (string)untypedValue;
            if (value.Length <= 40)
            {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly MagentaMinMaxLengthCheckConverter Singleton = new MagentaMinMaxLengthCheckConverter();
    }
}
